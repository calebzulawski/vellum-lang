use crate::ast::{Identifier, Item, Primitive, Pointer, PointerModifier, Struct, Type};
use crate::lexer;
use codespan::{ByteIndex, Span};

grammar;

extern {
    type Location = ByteIndex;
    type Error = ();

    enum lexer::Token {
        "{" => lexer::Token::LeftBracket,
        "}" => lexer::Token::RightBracket,
        ":" => lexer::Token::Colon,
        "," => lexer::Token::Comma,
        ";" => lexer::Token::Semicolon,
        "*" => lexer::Token::Asterisk,
        "primitive" => lexer::Token::Primitive(<Primitive>),
        "struct" => lexer::Token::Struct,
        "const" => lexer::Token::Const,
        "owned" => lexer::Token::Owned,
        "mut" => lexer::Token::Mut,
        "identifier" => lexer::Token::Identifier(<String>),
    }
}

Primitive: Primitive =
    "primitive" => <>;

IdentifierString: String =
    "identifier" => <>;

Identifier: Identifier =
    <l: @L> <identifier: IdentifierString> <r: @R> => Identifier { span: Span::new(l, r), identifier };

PointerModifier: PointerModifier = {
    "const" => PointerModifier::Const,
    "mut" => PointerModifier::Mut,
    "owned" => PointerModifier::Owned,
}

Pointer: Pointer =
    <l: @L> <modifier: PointerModifier> "*" <ty: Type> <r: @R> => Pointer { span: Span::new(l, r), modifier, ty: Box::new(ty) };

Type: Type = {
    <l: @L> <primitive: Primitive> <r: @R> => Type::Primitive { span: Span::new(l, r), primitive },
    <pointer: Pointer> => Type::Pointer(pointer),
    <identifier: Identifier> => Type::Identifier(identifier),
}

StructField: (Identifier, Type) =
    <identifier: Identifier> ":" <ty: Type> "," => (identifier, ty);

Struct: Struct =
    <l: @L> "struct" <name: Identifier> "{" <fields: StructField*> "}" <r: @R> => Struct { span: Span::new(l, r), name, fields };

Item: Item = {
    <s: Struct> => Item::Struct(s),
}

pub Program: Vec<Item> =
    <items: Item*> => <>;
