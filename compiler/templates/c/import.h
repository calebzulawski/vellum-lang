// -----------------------------------------------------------------------------
// This header is generated by the Vellum ABI compiler.
// Do not edit.
// -----------------------------------------------------------------------------

#pragma once

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <sys/types.h>

#ifndef VELLUM_ABI
#  if defined(VELLUM_STATIC)
#    define VELLUM_ABI
#  elif defined(_WIN32) || defined(__CYGWIN__)
#    define VELLUM_ABI __declspec(dllimport)
#  else
#    define VELLUM_ABI __attribute__((visibility("default")))
#  endif
#endif

{% import "c/_macros.h" as m %}

{% for s in items.abstract_structs -%}
{%- call m::docs("", s.docs) %}
struct {{ s.name }};
{% endfor %}

{% for s in items.structs %}
{%- call m::docs("", s.docs) %}
struct {{ s.name }} {
{%- for field in s.fields %}
{%- call m::docs("    ", field.docs) %}
    {{ field.ty|ty }} {{ field.name }};
{%- endfor %}
};

{% endfor %}

/* Concrete slice typedefs (C has no templates) */
{% for d in slice_decls %}
typedef struct { {{ d.elem_c_type }} * data; size_t len; } vellum_slice_{{ d.name }};
{% endfor %}

/* Concrete owned pointer typedefs */
{% for d in owned_ptr_decls %}
typedef struct { {{ d.data_c_type }} data; void (*deleter)({{ d.data_c_type }}); } vellum_owned_ptr_{{ d.name }};
{% endfor %}

/* Concrete owned slice typedefs (deleter takes fat pointer by value) */
{% for d in owned_slice_decls %}
typedef struct { {{ d.slice_name }} slice_data; void (*deleter)({{ d.slice_name }}); } vellum_owned_slice_{{ d.name }};
{% endfor %}

{% for f in items.functions %}
{%- call m::docs("", f.docs) %}
VELLUM_ABI {{ f.returns|retty }} {{ f.name }}(
{%- for arg in f.args %}
    {{ arg.1|ty }} {{ arg.0 }}{% call m::comma() %}
{%- endfor %}
) ;
{% endfor %}
